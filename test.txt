👇

🧩 Simple API 프로젝트 — 트러블슈팅 & 학습 모음집
1️⃣ Gradle 빌드 실패 (bootJar 설정 관련)

문제
GitHub Actions 빌드 과정에서 아래 오류 발생:

Could not get unknown property 'True' for task ':bootJar'


접근

bootJar 설정 시 잘못된 속성 사용 (True 대문자 Boolean literal 인식 실패)

Gradle 8.x 버전에서는 속성 정의를 Groovy 표준 방식으로 해야 함

해결

bootJar {
    enabled = true
}


으로 수정 후 빌드 성공.
이 과정에서 Spring Boot Gradle 플러그인의 구조를 이해하게 됨.

2️⃣ Docker Build 실패 (COPY gradle ./gradle 경로 문제)

문제
Docker build 시 다음 에러 발생:

failed to compute cache key: failed to calculate checksum of ref: "/gradle": not found


접근

Gradle wrapper (gradle/ 디렉토리)가 .dockerignore나 빌드 컨텍스트에 포함되지 않음

Dockerfile의 COPY gradle ./gradle 단계에서 참조 경로가 잘못됨

해결

프로젝트 루트 기준으로 빌드 컨텍스트를 설정

또는 COPY ./gradle ./gradle로 절대 경로 명시

.dockerignore에 gradle/ 제거

결과적으로 Gradle 의존성 캐싱과 빌드 캐시 구조를 명확히 이해하게 됨.

3️⃣ JAR 실행 실패 — “No ‘Start-Class’ manifest entry specified”

문제
컨테이너 실행 시 즉시 종료:

java.lang.IllegalStateException: No 'Start-Class' manifest entry specified


접근

JarLauncher가 Start-Class를 찾지 못함

원인은 Dockerfile에서 Spring Boot layertools 모드를 사용해 jar를 추출하면서
manifest 메타데이터(META-INF/MANIFEST.MF)가 손실된 것

즉, 런타임에 Spring Boot의 메인 클래스 정보를 찾을 수 없는 상태

해결
Dockerfile을 단순화:

FROM eclipse-temurin:21-jdk-jammy
WORKDIR /app
COPY build/libs/*.jar app.jar
EXPOSE 8080
ENTRYPOINT ["java", "-jar", "/app/app.jar"]


→ fat jar(모든 의존성 포함된 실행형 jar)를 그대로 실행하도록 변경
→ 컨테이너가 정상 부팅되고 로그에 Tomcat started on port 8080 확인

4️⃣ EC2에서 Spring Boot 서버 실행 후 외부 접근 불가

문제

curl localhost:8080/hello는 정상 동작하지만,

외부에서 http://<EC2-IP>:8080/hello 요청 시 응답 없음

접근

EC2 내부 네트워크는 정상 → 네트워크 계층 문제 추정

ufw(서버 방화벽)는 비활성화 상태

AWS Security Group(보안 그룹) 확인 → 8080 포트 미허용

해결
AWS 콘솔 → EC2 인스턴스 → 보안 그룹 → 인바운드 규칙 편집

Type: Custom TCP
Protocol: TCP
Port range: 8080
Source: 0.0.0.0/0


저장 후 외부 접속 성공 ✅

5️⃣ GitHub Actions 배포 실패 (Health Check 단계 실패)

문제
CI/CD 파이프라인의 마지막 단계에서 ❌ Deployment failed! Rolling back... 출력

접근

컨테이너가 정상적으로 run되지만 health check(curl http://localhost:8080/actuator/health)에서 실패

원인은 애플리케이션이 8080에서 실행되기 전에 health check를 수행했기 때문

해결
deploy.yml에 대기 시간(sleep 30) 추가
Spring Boot의 초기 부팅 시간(약 7~10초)을 고려해 안정성 확보
결과적으로 health check 통과 및 자동 배포 성공

6️⃣ 최종 검증 단계 — Postman & Actuator Test

문제
/hello 응답이 오지 않음

접근

URL 이중 슬래시 확인 (http://43.200.246.139:8080//hello)

올바른 요청 경로로 수정

해결
http://43.200.246.139:8080/hello 요청 시

{"message":"허재원이 말해요: Hello world"}


정상 응답 확인

🧠 프로젝트 전체에서 얻은 인사이트
분야	배운 핵심	요약
Gradle 빌드 구조	Spring Boot 플러그인의 역할과 bootJar 설정	Fat jar 생성 시 메타정보(Start-Class)가 핵심임
Docker 멀티스테이지 빌드	빌드 스테이지와 런타임 스테이지의 역할 구분	build → runtime 분리로 이미지 크기 최적화 가능
레이어드 빌드 (Layertools)	캐싱에는 유리하지만 manifest 손상 시 실행 불가	단순 배포엔 java -jar가 안정적
CI/CD 자동화	GitHub Actions + SSH 배포 + 헬스체크	지속적 배포 파이프라인의 필수 구성 요소 학습
AWS 네트워크 보안	인바운드 규칙의 중요성	애플리케이션은 내부에서 돌아가도, 포트가 막히면 접근 불가
로그 분석 역량	Spring Boot 부팅 로그 구조 파악	“Tomcat initialized” 이후 시점이 성공 포인트
서비스 검증 습관	curl과 actuator/health 활용	외부 요청 전 내부 검증으로 디버깅 효율화
✅ 최종 결과
항목	상태
Spring Boot 빌드 성공	✅
Docker 이미지 빌드 & GHCR 푸시	✅
GitHub Actions 자동 배포	✅
EC2 컨테이너 실행 및 헬스체크 통과	✅
외부 접근 /hello 정상 응답	✅